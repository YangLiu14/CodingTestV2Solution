__author__ = "Yang Liu"
__email__ = "lander14@outlook.com"

import tqdm
from typing import List, Dict

#####################################################
# Leetcode 629. K个逆序对数组

# 给定一个正整数 n，表示有1～N个数字随意排列。
# 给一个正整数 k，求在以上所有的排列方式中，
# 严格拥有 K 个逆序对的排列方式有多少个

# 例：n = 3, k = 1
# 在所有的排列中，只有:
# 132, 213 是只有一个逆序对，输出2
#####################################################

#####################################################
# 思路

# i 属于 1~n, j 属于 1~k
# dp[i][j] 表示：1~i的数字随意排列，正好满足j对逆序对的排列个数

# 例：现在想找到 dp[7][9] 对应的值，可以分以下几种情况讨论：
# 我们已经有了dp[6][9], 表示1~6数字排列，产生9对逆序对的情况。
# 此时考虑7的位置应该放在哪里:
# <1> 7放在最后，不会因此产生新的逆序对，因为此时7最大。于是情况1是 dp[6][9]
# <2> 7放倒数第二，此时7的出现一定会带来恰好一对逆序对，于是只要把dp[6][8]的情况加上
# <3> 7放倒数第三，dp[6][7]
# ...
#     一直枚举到 dp[6][3]

# 理解了状态更新后，让我们再进一步分析：
# dp[7][9] = sum( dp[6][9 ... 3] )
# dp[7][10] = sum( dp[6][10 ... 4] )
#
# dp[7][10] = dp[6][10] + dp[7][9] - dp[6][3]

# 于是我们总结出通用的状态转移方程
# dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j - i]

# 但是注意 ⚠️ 以上情况都只适用于 i <= j
# 对于 i > j：比如我们需要dp[7][3]

# <1> 7放最后，不产生逆序对 -> dp[6][3]
# <2> 7放倒数第二，产生一个恰好逆序对 -> dp[6][2]
# <3> 7放倒数第三，dp[6][1]
# <4> 7放倒数第四，dp[6][0]。结束，不再枚举

# dp[7][3] = sum( dp[6][3 ... 0] )
# dp[7][4] = sum( dp[6][4 ... 0] )
# dp[7][4] = dp[6][4] + dp[7][3] + 0

#####################################################


def k_inverse_pairs(n: int, k: int):
    if n < 0 or k < 0:
        return 0

    dp = [[0] * (k+1) for _ in range(n+1)]
    dp[0][0] = 1
    mod = 1000000007
    for i in range(1, n+1):
        dp[i][0] = 1  # 当k=0时，只有1种情况，就是1～i升序排列
        for j in range(1, k+1):
            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod
            if j >= i:
                dp[i][j] = (dp[i][j] - dp[i-1][j-i] + mod) % mod  # 加mod在这里很重要，因为之前的值除了余

    return dp[n][k]